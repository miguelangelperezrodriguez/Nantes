// Code generated by Icestudio 0.4.0
// Sat, 21 Sep 2019 20:38:25 GMT

`default_nettype none

`include "divider.vh"

//declare the Verilog module - The inputs and output signals.
module mux2to1(
    out,
    ctrl,
    in1,in2
    );

    //what are the input ports.
    input in1;
    input in2;
    input ctrl;
    //What are the output ports.
    output out;
    reg out;
    //Always block - the statements inside this block are executed when the given sensitivity list
    //is satidfied. for example in this case the block is executed when any changes occur in the three signals
    //named 'Data_in_0','Data_in_1' or 'sel'.
    always @(in1,in2,ctrl)
    begin
        if(ctrl == 0)
            out = in1;  //when select signal to the mux is low
        else
            out = in2;  //when select signal to the mux is high
    end

endmodule

module mux21_sw (out,ctrl,in1,in2);
  output out;
  input ctrl,in1,in2;
  wire  out_inv;

  supply1 power;
  supply0 ground;

  pmos p1(out_inv,power,ctrl);
  nmos n1(out_inv,ground,ctrl);


  cmos C1 (out,in1,out_inv,ctrl);
  cmos C2 (out,in2,ctrl,out_inv);

endmodule

module mux42_sw (out_42,ctrl_42,in_42);
  output out_42;
  input [1:0] ctrl_42;
  input [3:0] in_42;

  wire w_11,w_12;

  mux21_sw muxnivel1_1 (
    .out (w_11),
    .ctrl (ctrl_42[0]),
    .in1(in_42[0]),
    .in2(in_42[1])
  );

  mux21_sw muxnivel1_2 (
    .out (w_12),
    .ctrl (ctrl_42[0]),
    .in1 (in_42[2]),
    .in2 (in_42[3])
  );

  mux21_sw muxnivel2 (
    .out (out_42),
    .ctrl (ctrl_42[1]),
    .in1 (w_11),
    .in2 (w_12)
  );


endmodule




module mux2xcanal2 (out0,out1,ctrl,a0,a1,b0,b1);
  output out0,out1;
  input ctrl,a0,a1,b0,b1;


  mux2to1 mux_1 (out0,ctrl,a0,b0);
  mux2to1 mux_2 (out1,ctrl,a1,b1);

endmodule


// SISTEMA PIPELINE. SELECCION CON 3 BUSES.
// PUDIENDO FUNCIONAR CON B2,B1 o B1,B0
// TENIENDO PRIORIDAD EN B2,B1
//  Bpas. QUE FUNCIONA CON DICHOS BUSES INDIVIDUAL
// O B2,B1 Y B1,B0. Y SIN ENTRADAS FUNCIONA
// CONECTADO A UN AUTOMATA
// SEÑALES ENTRADA ; A2 A1 A0
// SALIDAS DISPARADORES DE BUSES; B2 B1 B0
// SALIDA CONTROL : Bpas Bpas_activo EN1 EN0 : INDICA EL PAR DE BUSES
// UTILIZADO.

// NOTA: B2 es igual a A2 y B1 es igual a A1.

module transformador_mux_senales (t_Bpas,t_Bpas_act,t_EN1,t_EN2,t_B2,t_B1,t_B0,t_A2,t_A1,t_A0);
  output t_B0,t_B1,t_B2,t_Bpas,t_Bpas_act,t_EN1,t_EN2;
  input t_A2,t_A1,t_A0;

  assign t_B0 = (~t_A2 & ~t_A1 & t_A0) | (~t_A2 & t_A1 & t_A0);
  assign t_B1 = t_A1;
  assign t_B2 = t_A2;

  assign t_Bpas = (~t_A2 & ~t_A1 & ~t_A0) | (t_A0 & t_A1) | (t_A1 & t_A2);
  assign t_Bpas_act = (t_A2 & t_A1) | (t_A1 & t_A0);
  assign t_EN1 = (~t_A2 & t_A1) | (~t_A2 & t_A0);
  assign t_EN2 =  t_A2;

endmodule

module ser32to8(
    input wire clk,
    input wire [31:0] in,
    output reg [7:0] out
    );

    reg [1:0] cnt = 2'b00;
    always @(posedge clk)
      cnt <= cnt + 1;

    always @* begin
      case (cnt)
        2'd0: out = in[7:0];
        2'd1: out = in[15:8];
        2'd2: out = in[23:16];
        2'd3: out = in[31:24];
        default: out = 8'h00;
      endcase
    end
endmodule



module cod_Prioridad (I,A2,A1,A0);
output A2,A1,A0;
input  [7:0]I;

assign A2 = I[4] | I[5] | I[6] | I[7];
assign A1 = (~I[5] & ~I[4] & I[2]) | (~I[5] & ~I[4] & I[3]) | I[6] | I[7];
assign A0 = (~I[6] & ~I[4] & ~I[2] & I[1]) | (~I[6] & ~I[4] & I[3]) | (~I[6] & I[5]) | I[7];

endmodule

module inv_sw (out,in);
  output out;
  input  in;

  supply1 power;
  supply0 ground;

  pmos p1(out,power,in);
  nmos p2(out,ground,in);

endmodule

module nand_sw (out,A,B);
  output out;
  input A,B;
  wire sal1;

  supply1 power;
  supply0 ground;

  pmos p1 (out,power,A);
  pmos p2 (out,power,B);

  nmos n1 (out,sal1,A);
  nmos n2 (sal1,ground,B);

endmodule

module nor_sw (out,A,B);
  output out;
  input A,B;
  wire sal1;

  supply1 power;
  supply0 ground;

  pmos p1(sal1,power,A);
  pmos p2(out,sal1,B);

  nmos n1(out,ground,A);
  nmos n2(out,ground,B);

endmodule

module not_exor (out,a,b);
  output out;
  input a,b;

  assign out = (~a & ~b) | (a & b);

endmodule

module not_exor_nmos (out,a,b);
  output out;
  input a,b;
  wire sal1;
  wire sal2;

  assign sal1 = (~a & ~b) | (a & b);

  supply0 ground;

  nmos n1 (sal2,ground,sal1);
  nmos n2 (out,ground,sal2);


endmodule

module not_exor_pmos (out,a,b);
  output out;
  input a,b;
  wire sal1;
  wire sal2;

  assign sal1 = (~a & ~b) | (a & b);

  supply1 power;

  nmos p1 (sal2,power,sal1);
  nmos p2 (out,power,sal2);

endmodule

module jk (J,K,clk,Q,Q1);
output Q,Q1;
input J,K,clk;
reg Q,Q1;
initial begin Q=1'b0; Q1=1'b1; end
always @ (posedge clk)
  begin
	case({J,K})
		 {1'b0,1'b0}:begin Q=Q; Q1=Q1; end
		 {1'b0,1'b1}: begin Q=1'b0; Q1=1'b1; end
		 {1'b1,1'b0}:begin Q=1'b1; Q1=1'b0; end
		 {1'b1,1'b1}: begin Q=~Q; Q1=~Q1; end
	endcase
  end
endmodule

module dq (D,clk,d_Q,d_Q1);
output d_Q,d_Q1;
input  D,clk;

  jk instancia_JK (
    .J(D),
    .K(~D),
    .clk (clk),
    .Q (d_Q),
    .Q1 (d_Q1)
  );

endmodule

module mux_bus8 (
    input [7:0] A,
    input [7:0] B,
    input ctrl,
    output [7:0] D);

    mux2to1 i_1 (D[0],ctrl,A[0],B[0]);
    mux2to1 i_2 (D[1],ctrl,A[1],B[1]);
    mux2to1 i_3 (D[2],ctrl,A[2],B[2]);
    mux2to1 i_4 (D[3],ctrl,A[3],B[3]);
    mux2to1 i_5 (D[4],ctrl,A[4],B[4]);
    mux2to1 i_6 (D[5],ctrl,A[5],B[5]);
    mux2to1 i_7 (D[6],ctrl,A[6],B[6]);
    mux2to1 i_8 (D[7],ctrl,A[7],B[7]);

endmodule

module decodf_1_2 (
    input W,
    output [1:0] salida
    );

    reg salida;

    always @(*)
    begin
    case (W)
      1'b0 :      	//Hexadecimal 0
      salida = 2'b01;
      1'b1 :    		//Hexadecimal 1
      salida = 2'b10;
    endcase
    end
endmodule


module decodf_2_4 (
    input [1:0] W,
    output [3:0] salida
    );

    reg salida;

    always @(*)
    begin
    case (W)
      2'b00 :      	//Hexadecimal 0
      salida = 4'b0001;
      2'b01 :    		//Hexadecimal 1
      salida = 4'b0010;
      2'b10 :  		// Hexadecimal 2
      salida = 4'b0100;
      2'b11 : 		// Hexadecimal 3
      salida = 4'b1000;
    endcase
    end
endmodule



module decodf_BCD_CC(
    input  [3:0]x,
    output reg [6:0]z
    );
always @*
case (x)
4'b0000 :      	//Hexadecimal 0
z = 7'b1111110;
4'b0001 :    		//Hexadecimal 1
z = 7'b0110000  ;
4'b0010 :  		// Hexadecimal 2
z = 7'b1101101 ;
4'b0011 : 		// Hexadecimal 3
z = 7'b1111001 ;
4'b0100 :		// Hexadecimal 4
z = 7'b0110011 ;
4'b0101 :		// Hexadecimal 5
z = 7'b1011011 ;
4'b0110 :		// Hexadecimal 6
z = 7'b1011111 ;
4'b0111 :		// Hexadecimal 7
z = 7'b1110000;
4'b1000 :     		 //Hexadecimal 8
z = 7'b1111111;
4'b1001 :    		//Hexadecimal 9
z = 7'b1111011 ;
4'b1010 :  		// Hexadecimal A
z = 7'b1110111 ;
4'b1011 : 		// Hexadecimal B
z = 7'b0011111;
4'b1100 :		// Hexadecimal C
z = 7'b1001110 ;
4'b1101 :		// Hexadecimal D
z = 7'b0111101 ;
4'b1110 :		// Hexadecimal E
z = 7'b1001111 ;
4'b1111 :		// Hexadecimal F
z = 7'b1000111 ;
endcase

endmodule

module Comparador_1 (
  input A,
  input B,
  output Amayor,
  output Bmayor,
  output ABiguales
);

  assign Amayor = (A>B)?1'b1:1'b0;
  assign Bmayor = (A<B)?1'b1:1'b0;
  assign ABiguales = (A==B)?1'b1:1'b0;

endmodule

module Comparador_8 (
  input [7:0] A,
  input [7:0] B,
  output Amayor,
  output Bmayor,
  output ABiguales
  );

  assign Amayor = (A>B)?1'b1:1'b0;
  assign Bmayor = (A<B)?1'b1:1'b0;
  assign ABiguales = (A==B)?1'b1:1'b0;

endmodule

module semisumador_completo (
  input A,
  input B,
  input Ci,
  output S,
  output Cs
);

wire w1,w2,w3;

assign w1 = A ^ B;
assign w2 = A & B;
assign S = w1 ^ Ci;
assign w3 = w1 & Ci;
assign Cs =  w3 | w2;

endmodule

module carry_lookahead_adder_8_bit
  (
   input [7:0]  i_add1,
   input [7:0]  i_add2,
   output [8:0] o_result
   );

  wire [8:0]    w_C;
  wire [7:0]    w_G, w_P, w_SUM;

  semisumador_completo full_adder_bit_0
    (
      .A(i_add1[0]),
      .B(i_add2[0]),
      .Ci(w_C[0]),
      .S(w_SUM[0]),
      .Cs()
      );

  semisumador_completo full_adder_bit_1
    (
      .A(i_add1[1]),
      .B(i_add2[1]),
      .Ci(w_C[1]),
      .S(w_SUM[1]),
      .Cs()
      );

  semisumador_completo full_adder_bit_2
    (
      .A(i_add1[2]),
      .B(i_add2[2]),
      .Ci(w_C[2]),
      .S(w_SUM[2]),
      .Cs()
      );

  semisumador_completo full_adder_bit_3
    (
      .A(i_add1[3]),
      .B(i_add2[3]),
      .Ci(w_C[3]),
      .S(w_SUM[3]),
      .Cs()
      );

  semisumador_completo full_adder_bit_4
    (
      .A(i_add1[4]),
      .B(i_add2[4]),
      .Ci(w_C[4]),
      .S(w_SUM[4]),
      .Cs()
    );

  semisumador_completo full_adder_bit_5
    (
      .A(i_add1[5]),
      .B(i_add2[5]),
      .Ci(w_C[5]),
      .S(w_SUM[5]),
      .Cs()
    );

  semisumador_completo full_adder_bit_6
    (
      .A(i_add1[6]),
      .B(i_add2[6]),
      .Ci(w_C[6]),
      .S(w_SUM[6]),
      .Cs()
    );

  semisumador_completo full_adder_bit_7
    (
      .A(i_add1[7]),
      .B(i_add2[7]),
      .Ci(w_C[7]),
      .S(w_SUM[7]),
      .Cs()
    );


  // Create the Generate (G) Terms:  Gi=Ai*Bi
  assign w_G[0] = i_add1[0] & i_add2[0];
  assign w_G[1] = i_add1[1] & i_add2[1];
  assign w_G[2] = i_add1[2] & i_add2[2];
  assign w_G[3] = i_add1[3] & i_add2[3];
  assign w_G[4] = i_add1[4] & i_add2[4];
  assign w_G[5] = i_add1[5] & i_add2[5];
  assign w_G[6] = i_add1[6] & i_add2[6];
  assign w_G[7] = i_add1[7] & i_add2[7];

  // Create the Propagate Terms: Pi=Ai+Bi
  assign w_P[0] = i_add1[0] | i_add2[0];
  assign w_P[1] = i_add1[1] | i_add2[1];
  assign w_P[2] = i_add1[2] | i_add2[2];
  assign w_P[3] = i_add1[3] | i_add2[3];
  assign w_P[4] = i_add1[4] | i_add2[4];
  assign w_P[5] = i_add1[5] | i_add2[5];
  assign w_P[6] = i_add1[6] | i_add2[6];
  assign w_P[7] = i_add1[7] | i_add2[7];

  // Create the Carry Terms:
  assign w_C[0] = 1'b0; // no carry input
  assign w_C[1] = w_G[0] | (w_P[0] & w_C[0]);
  assign w_C[2] = w_G[1] | (w_P[1] & w_C[1]);
  assign w_C[3] = w_G[2] | (w_P[2] & w_C[2]);
  assign w_C[4] = w_G[3] | (w_P[3] & w_C[3]);
  assign w_C[5] = w_G[4] | (w_P[4] & w_C[4]);
  assign w_C[6] = w_G[5] | (w_P[5] & w_C[5]);
  assign w_C[7] = w_G[6] | (w_P[6] & w_C[6]);
  assign w_C[8] = w_G[7] | (w_P[7] & w_C[7]);


  assign o_result = {w_C[8], w_SUM};   // Verilog Concatenation

endmodule // carry_lookahead_adder_4_bit

//Sumador-restador a complemento 2
module carry_lookahead_adder_subber_8_bit
  (
   input [7:0]  i_add1,
   input [7:0]  i_add2,
   input        S_R,
   output [7:0] o_result,
   output acarreo
   );

  wire [7:0]    w_C;
  wire [7:0]    w_G, w_P, w_SUM;

  assign w_C[0] = S_R;

  wire [7:0] xor_B;

  assign xor_B[0] = i_add2[0] ^ S_R;
  assign xor_B[1] = i_add2[1] ^ S_R;
  assign xor_B[2] = i_add2[2] ^ S_R;
  assign xor_B[3] = i_add2[3] ^ S_R;
  assign xor_B[4] = i_add2[4] ^ S_R;
  assign xor_B[5] = i_add2[5] ^ S_R;
  assign xor_B[6] = i_add2[6] ^ S_R;
  assign xor_B[7] = i_add2[7] ^ S_R;

  semisumador_completo full_adder_bit_0
    (
      .A(i_add1[0]),
      .B(xor_B[0]),
      .Ci(w_C[0]),
      .S(w_SUM[0]),
      .Cs()
      );

  semisumador_completo full_adder_bit_1
    (
      .A(i_add1[1]),
      .B(xor_B[1]),
      .Ci(w_C[1]),
      .S(w_SUM[1]),
      .Cs()
      );

  semisumador_completo full_adder_bit_2
    (
      .A(i_add1[2]),
      .B(xor_B[2]),
      .Ci(w_C[2]),
      .S(w_SUM[2]),
      .Cs()
      );

  semisumador_completo full_adder_bit_3
    (
      .A(i_add1[3]),
      .B(xor_B[3]),
      .Ci(w_C[3]),
      .S(w_SUM[3]),
      .Cs()
      );

  semisumador_completo full_adder_bit_4
    (
      .A(i_add1[4]),
      .B(xor_B[4]),
      .Ci(w_C[4]),
      .S(w_SUM[4]),
      .Cs()
    );

  semisumador_completo full_adder_bit_5
    (
      .A(i_add1[5]),
      .B(xor_B[5]),
      .Ci(w_C[5]),
      .S(w_SUM[5]),
      .Cs()
    );

  semisumador_completo full_adder_bit_6
    (
      .A(i_add1[6]),
      .B(xor_B[6]),
      .Ci(w_C[6]),
      .S(w_SUM[6]),
      .Cs()
    );

  semisumador_completo full_adder_bit_7
    (
      .A(i_add1[7]),
      .B(xor_B[7]),
      .Ci(w_C[7]),
      .S(w_SUM[7]),
      .Cs()
    );


  // Create the Generate (G) Terms:  Gi=Ai*Bi
  assign w_G[0] = i_add1[0] & xor_B[0];
  assign w_G[1] = i_add1[1] & xor_B[1];
  assign w_G[2] = i_add1[2] & xor_B[2];
  assign w_G[3] = i_add1[3] & xor_B[3];
  assign w_G[4] = i_add1[4] & xor_B[4];
  assign w_G[5] = i_add1[5] & xor_B[5];
  assign w_G[6] = i_add1[6] & xor_B[6];
  assign w_G[7] = i_add1[7] & xor_B[7];

  // Create the Propagate Terms: Pi=Ai+Bi
  assign w_P[0] = i_add1[0] | xor_B[0];
  assign w_P[1] = i_add1[1] | xor_B[1];
  assign w_P[2] = i_add1[2] | xor_B[2];
  assign w_P[3] = i_add1[3] | xor_B[3];
  assign w_P[4] = i_add1[4] | xor_B[4];
  assign w_P[5] = i_add1[5] | xor_B[5];
  assign w_P[6] = i_add1[6] | xor_B[6];
  assign w_P[7] = i_add1[7] | xor_B[7];

  // Create the Carry Terms:
  assign w_C[0] = S_R;
  assign w_C[1] = w_G[0] | (w_P[0] & w_C[0]);
  assign w_C[2] = w_G[1] | (w_P[1] & w_C[1]);
  assign w_C[3] = w_G[2] | (w_P[2] & w_C[2]);
  assign w_C[4] = w_G[3] | (w_P[3] & w_C[3]);
  assign w_C[5] = w_G[4] | (w_P[4] & w_C[4]);
  assign w_C[6] = w_G[5] | (w_P[5] & w_C[5]);
  assign w_C[7] = w_G[6] | (w_P[6] & w_C[6]);

  assign acarreo = w_C[7] & ~S_R;

  assign o_result = {w_C[7], w_SUM};   // Verilog Concatenation

endmodule // carry_lookahead_adder_4_bit

module banco_registros2x5bits (
  input W_banco,
  input R_banco,
  input Gw,
  input Gr,
  input  [4:0] E,
  output [4:0] S
);

  wire [1:0] w_deco;

  wire w_deco_and_0;
  wire w_deco_and_1;

  wire Q00,Q01,Q02,Q03,Q04;
  wire Q10,Q11,Q12,Q13,Q14;

  wire [4:0] PreSalida;

  decodf_1_2 deco_escritura (
      .W (W_banco),
      .salida (w_deco)
  );

  assign w_deco_and_0 = w_deco[0] & (~Gw);
  assign w_deco_and_1 = w_deco[1] & (~Gw);

  //dq (D,clk,d_Q,d_Q1);
  dq dq_0_bit0 (
    .D (E[0]),
    .clk (w_deco_and_0),
    .d_Q (Q00)
  );
  dq dq_0_bit1 (
    .D (E[1]),
    .clk (w_deco_and_0),
    .d_Q (Q01)
  );
  dq dq_0_bit2 (
    .D (E[2]),
    .clk (w_deco_and_0),
    .d_Q (Q02)
  );
  dq dq_0_bit3 (
    .D (E[3]),
    .clk (w_deco_and_0),
    .d_Q (Q03)
  );
  dq dq_0_bit4 (
    .D (E[4]),
    .clk (w_deco_and_0),
    .d_Q (Q04)
  );


  dq dq_1_bit0 (
      .D (E[0]),
      .clk (w_deco_and_1),
      .d_Q (Q10)
  );
  dq dq_1_bit1 (
      .D (E[1]),
      .clk (w_deco_and_1),
      .d_Q (Q11)
  );
  dq dq_1_bit2 (
      .D (E[2]),
      .clk (w_deco_and_1),
      .d_Q (Q12)
  );
  dq dq_1_bit3 (
      .D (E[3]),
      .clk (w_deco_and_1),
      .d_Q (Q13)
  );
  dq dq_1_bit4 (
      .D (E[4]),
      .clk (w_deco_and_1),
      .d_Q (Q14)
  );

  mux2to1 seleccion_0 (
    .out(PreSalida[0]),
    .ctrl(R_banco),
    .in1(Q00),
    .in2(Q10)
  );

  mux2to1 seleccion_1 (
    .out (PreSalida[1]),
    .ctrl(R_banco),
    .in1(Q01),
    .in2(Q11)
  );

  mux2to1 seleccion_2 (
    .out(PreSalida[2]),
    .ctrl(R_banco),
    .in1(Q02),
    .in2(Q12)
  );

  mux2to1 seleccion_3 (
    .out(PreSalida[3]),
    .ctrl(R_banco),
    .in1(Q03),
    .in2(Q13)
  );

  mux2to1 seleccion_4 (
    .out(PreSalida[4]),
    .ctrl(R_banco),
    .in1(Q04),
    .in2(Q14)
  );

  assign S[0] = PreSalida[0] & (~Gr);
  assign S[1] = PreSalida[1] & (~Gr);
  assign S[2] = PreSalida[2] & (~Gr);
  assign S[3] = PreSalida[3] & (~Gr);
  assign S[4] = PreSalida[4] & (~Gr);

endmodule

//- divM.v
module divM(input wire clk_in, output wire clk_out);

//-- Valor por defecto del divisor
//-- Como en la iCEstick el reloj es de 12MHz, ponermos un valor de 12M
//-- para obtener una frecuencia de salida de 1Hz
parameter M = 12_000_000;

//-- Numero de bits para almacenar el divisor
//-- Se calculan con la funcion de verilog $clog2, que nos devuelve el
//-- numero de bits necesarios para representar el numero M
//-- Es un parametro local, que no se puede modificar al instanciar
localparam N = $clog2(M);

//-- Registro para implementar el contador modulo M
reg [N-1:0] divcounter = 0;

//-- Contador módulo M
always @(posedge clk_in)
  if (divcounter == M - 1)
    divcounter <= 0;
  else
    divcounter <= divcounter + 1;

//-- Sacar el bit mas significativo por clk_out
assign clk_out = divcounter[N-1];

endmodule


/*
-----------------------------------------------------------------------
| 1 0010 |
| REGISTRO A:
|              A[0] : RST CERO
|              A[1] : RST VALOR_GUARDADO
|              A[2] : ADD RELOJ . ALTERNANDO CON CERO
|              A[3] : ADD PASO
|              A[4] : SUB RELOJ
|              A[5] : SUB PASO. ALTERNADO CON CERO
|              A[6] : CARGAR DATO
|              A[7] : CONTAR N VALORES.
|              DESPUES DE ACTIVAR EL CONTAR SE PUEDE
|              SUMAR , RESTAR CON RELOJ O POR PASOS
|              NECESITA RESETEARSE PARA INVALIDARLO.
|              AL TERMINAR DEBE DAR UNA SEÑAL DE TERMINACION
-----------------------------------------------------------------------*/

module registro8 (
    input clk,
    input res_cero,
    input res_valor,
    input add_reloj,
    input add_paso,
    input sub_reloj,
    input sub_paso,
    input cargar_dato,
    input contar_n,
    input [7:0] valor_B_ALU,
    output [7:0] countout,
    output signal_end
);

  wire clk,res_cero,res_valor,read,mostrar_dato,add_reloj,add_paso,
       sub_reloj,sub_paso,cargar_dato,contar_n;
  wire [7:0] valor_B_ALU;
  reg [7:0] countout;
  reg signal_end;
  reg [7:0] valor_carga;

  reg activo_cuenta;
  reg [7:0] pasos_sin_hacer;

  initial begin
    valor_carga <= 8'b00000000;
    activo_cuenta <= 1'b0;
    pasos_sin_hacer <= 8'b00000000;
    signal_end <= 1'b0;
  end

  always @(posedge clk)
  begin
    if (res_cero==1'b1)
    begin
      countout <= 0;
      activo_cuenta <= 1'b0;
      pasos_sin_hacer <= 1'b0;
      signal_end <= 1'b0;
    end
    else  if (res_valor==1'b1)
    begin
      countout <= valor_carga;
      activo_cuenta <= 1'b0;
      pasos_sin_hacer <= 1'b0;
      signal_end <= 1'b0;
    end
    else if (add_reloj==1'b1) begin
      if (activo_cuenta==1'b1) begin
        if (pasos_sin_hacer>0)
        begin
          countout <= countout + 1;
          pasos_sin_hacer<=pasos_sin_hacer -1;
          if (pasos_sin_hacer==0)
            signal_end <= 1'b1;
        end
      end
      else
        countout <= countout + 1;
    end
    else if (sub_reloj==1'b1)
    begin
    if (activo_cuenta==1'b1) begin
      if (pasos_sin_hacer>0) begin
        countout <= countout - 1;
        pasos_sin_hacer<=pasos_sin_hacer -1;
        if (pasos_sin_hacer==0)
          signal_end <= 1'b1;
      end
    end
    else
      countout <= countout - 1;
    end
    else if (cargar_dato==1'b1) begin
      valor_carga <= valor_B_ALU;
      countout <= valor_B_ALU;
    end
    else if (contar_n==1'b1) begin
      activo_cuenta = ~activo_cuenta;
      pasos_sin_hacer = valor_B_ALU;
    end
  end

  always @(add_paso)
  begin
    countout<=countout + 1;
  end

  always @(sub_paso)
  begin
    countout<=countout - 1;
  end

  always @(activo_cuenta)
  begin
    if (pasos_sin_hacer>0)
      activo_cuenta=1'b1;
  end

endmodule

// Generación de nros. aleatorios
module fibonacci_lfsr_8bit(
  input clk,
  input rst_n,

  output reg [7:0] data
);

reg [7:0] data_next;

always @(*) begin

  data_next[7] = data[7]^data[1];
  data_next[6] = data[6]^data[0];
  data_next[5] = data[5]^data_next[7];
  data_next[4] = data[4]^data_next[6];
  data_next[3] = data[3]^data_next[5];
  data_next[2] = data[2]^data_next[4];
  data_next[1] = data[1]^data_next[3];
  data_next[0] = data[0]^data_next[2];
end

always @(posedge clk or negedge rst_n)
  if(!rst_n)
    data <= 8'hff;
  else
    data <= data_next;

endmodule

/* NOTAS MUSICALES
// SEÑALES:
// A[3:0] nro.nota musical
*/
module notas(
  clk, i_nota, chsalida);

input clk;
input [6:3] i_nota;
output chsalida;

wire clk;

wire ch0,ch1,ch2,ch3,ch4,ch5,ch6,ch7,ch8,ch9,ch10,ch11,ch12;

reg chsalida;

parameter N0 = `DO_4;
parameter N1 = `DOs_4;
parameter N2 = `RE_4;
parameter N3 = `REs_4;
parameter N4 = `MI_4;
parameter N5 = `FA_4;
parameter N6 = `FAs_4;
parameter N7 = `SOL_4;
parameter N8 = `SOLs_4;
parameter N9 = `LA_4;
parameter N10 = `LAs_4;
parameter N11 = `SI_4;
parameter N12 = `DO_5;

//-- Generador de tono 0
divM #(N0)
  CH0 (
    .clk_in(clk),
    .clk_out(ch0)
  );

//-- Generador de tono 1
divM #(N1)
  CH1 (
    .clk_in(clk),
    .clk_out(ch1)
  );

//-- Generador de tono 2
divM #(N2)
  CH2 (
    .clk_in(clk),
    .clk_out(ch2)
  );

//-- Generador de tono 3
divM #(N3)
  CH3 (
    .clk_in(clk),
    .clk_out(ch3)
  );

divM #(N4)
  CH4 (
    .clk_in(clk),
    .clk_out(ch4)
  );

divM #(N5)
  CH5 (
    .clk_in(clk),
    .clk_out(ch5)
  );

divM #(N6)
  CH6 (
    .clk_in(clk),
    .clk_out(ch6)
  );

divM #(N7)
  CH7 (
    .clk_in(clk),
    .clk_out(ch7)
  );

divM #(N8)
  CH8 (
      .clk_in(clk),
      .clk_out(ch8)
  );

divM #(N9)
  CH9 (
    .clk_in(clk),
    .clk_out(ch9)
  );

divM #(N10)
  CH10 (
    .clk_in(clk),
    .clk_out(ch10)
  );

divM #(N11)
  CH11 (
    .clk_in(clk),
    .clk_out(ch11)
);

divM #(N12)
  CH12 (
    .clk_in(clk),
    .clk_out(ch12)
);


always @(negedge clk) begin
  case (i_nota)
    4'b0000 :
      chsalida <= ch0;
    4'b0001 :
      chsalida <= ch1;
    4'b0010 :
      chsalida <= ch2;
    4'b0011 :
      chsalida <= ch3;
    4'b0100 :
      chsalida <= ch4;
    4'b0101 :
      chsalida <= ch5;
    4'b0110 :
      chsalida <= ch6;
    4'b0111 :
      chsalida <= ch7;
    4'b1000 :
      chsalida <= ch8;
    4'b1001 :
      chsalida <= ch9;
    4'b1010 :
      chsalida <= ch10;
    4'b1011 :
      chsalida <= ch11;
    4'b1100 :
      chsalida <= ch12;
  endcase
end
endmodule

/* ALU Arithmetic and Logic Operations
----------------------------------------------------------------------
|ALU_Sel|   ALU Operation
----------------------------------------------------------------------
| 0000  |   ALU_Out = A + B;
----------------------------------------------------------------------
| 0001  |   ALU_Out = A - B;
----------------------------------------------------------------------
| 0010  |   ALU_Out = A * B;
----------------------------------------------------------------------
| 0011  |   ALU_Out = A / B;
----------------------------------------------------------------------
| 0100  |   ALU_Out = A << 1;
----------------------------------------------------------------------
| 0101  |   ALU_Out = A >> 1;
----------------------------------------------------------------------
| 0110  |   ALU_Out = A rotated left by 1;
----------------------------------------------------------------------
| 0111  |   ALU_Out = A rotated right by 1;
----------------------------------------------------------------------
| 1000  |   ALU_Out = A and B;
----------------------------------------------------------------------
| 1001  |   ALU_Out = A or B;
----------------------------------------------------------------------
| 1010  |   ALU_Out = A xor B;
----------------------------------------------------------------------
| 1011  |   ALU_Out = A nor B;
----------------------------------------------------------------------
| 1100  |   ALU_Out = A nand B;
----------------------------------------------------------------------
| 1101  |   ALU_Out = A xnor B;
----------------------------------------------------------------------
| 1110  |   ALU_Out = 1 if A>B else 0;
----------------------------------------------------------------------
| 1111  |   ALU_Out = 1 if A=B else 0;
----------------------------------------------------------------------
| 1 0000 | BCD C_C
-----------------------------------------------------------------------
| 1 0001 | SEÑALES DE BUSES
-----------------------------------------------------------------------
| 1 0010 |
| REGISTRO B:
|              A[0] : RST CERO
|              A[1] : RST VALOR_GUARDADO
|              A[2] : ADD RELOJ
|              A[3] : ADD PASO
|              A[4] : SUB RELOJ
|              A[5] : SUB PASO
|              A[6] : CARGAR DATO
|              A[7] : CONTAR N VALORES
|   SE DEBE RESETEAR Y DA SEÑAL SIG_END
-----------------------------------------------------------------------
| 1 0011  : NRO ALEATOIO FIBONACCI
|         REGISTRO A[0] RESETEARSE a cero
|-----------------------------------------------------------------------*/

module UC (
      input clk,
      output salida_sonido
  );


notas inst_sonido (
  .clk (clk),
  .i_nota (4'b0101),
  .chsalida (salida_sonido)
);

endmodule


module alu(
           input clk,
           input [7:0] A,B,  // ALU 8-bit Inputs
           input [4:0] ALU_Sel,// ALU Selection
           output [7:0] ALU_Out, // ALU 8-bit Output
           output CarryOut // Carry Out Flag
    );

    decodf_BCD_CC decod (
        .x(A[3:0]),
        .z(salida_BCD)
    );

    transformador_mux_senales mux_signal (
      .t_Bpas (salida_MUX_Signal[3]),
      .t_Bpas_act (salida_MUX_Signal[2]),
      .t_EN1 (salida_MUX_Signal[1]),
      .t_EN2 (salida_MUX_Signal[0]),
      .t_B2 (salida_MUX_Signal[6]),
      .t_B1 (salida_MUX_Signal[5]),
      .t_B0 (salida_MUX_Signal[4]),
      .t_A2 (A[2]),
      .t_A1 (A[1]),
      .t_A0 (A[0])
    );

    // Registro vectorizado
    registro8 inst_regA (
      .clk (clk),
      .res_cero   (A[0]),
      .res_valor  (A[1]),
      .add_reloj  (A[2]),
      .add_paso   (A[3]),
      .sub_reloj  (A[4]),
      .sub_paso   (A[5]),
      .cargar_dato (A[6]),
      .contar_n    (A[7]),
      .valor_B_ALU (B),
      .signal_end (sig_end),
      .countout (t_cont_valor)
    );

    fibonacci_lfsr_8bit int_aleatorio    (
      .clk (clk),
      .rst_n (A[0]),
      .data (t_aleatorio)
    );


    //Registros de 8 bits
    reg [7:0] regB,regC,regD;

    wire [6:0] salida_BCD;
    wire [6:0] salida_MUX_Signal;
    wire [8:0] tmp;
    wire [7:0] t_cont_valor;
    wire [7:0] t_aleatorio;
    wire sig_end;


    assign tmp = {1'b0,A} + {1'b0,B};
    assign CarryOut = tmp[8]; // Carryout flag

    reg [7:0] ALU_Result;
    assign ALU_Out = ALU_Result; // ALU out
    always @(*)
    begin
        case(ALU_Sel)
        5'b00000: // Addition
           ALU_Result = A+B;
        5'b00001: // Subtraction
           ALU_Result = A-B;
        5'b00010: // Multiplication
           ALU_Result = A * B;
        5'b00011: // Division
           ALU_Result = A/B;
        5'b00100: // Logical shift left
           ALU_Result = A<<1;
         5'b00101: // Logical shift right
           ALU_Result = A>>1;
          5'b00110: // Rotate left
           ALU_Result = {A[6:0],A[7]};
           5'b00111: // Rotate right
           ALU_Result = {A[0],A[7:1]};
          5'b01000: //  Logical and
           ALU_Result = A & B;
          5'b01001: //  Logical or
           ALU_Result = A | B;
          5'b01010: //  Logical xor
           ALU_Result = A ^ B;
          5'b01011: //  Logical nor
           ALU_Result = ~(A | B);
          5'b01100: // Logical nand
           ALU_Result = ~(A & B);
          5'b01101: // Logical xnor
           ALU_Result = ~(A ^ B);
          5'b01110: // Greater comparison
           ALU_Result = (A>B)?8'd1:8'd0 ;
          5'b01111: // Equal comparison
            ALU_Result = (A==B)?8'd1:8'd0 ;
          5'b10000 : // BCD C_C
            ALU_Result = {1'b0,salida_BCD};
          5'b10001 :  // SEÑALES DEL BUS
            ALU_Result = {1'b0,salida_MUX_Signal};
          5'b10010 :
            ALU_Result = t_cont_valor;
          5'b10011 :
            ALU_Result = t_aleatorio;
        default: ALU_Result = A + B ;
        endcase
    end

endmodule
